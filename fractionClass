//header file
#pragma once
#include<string>
#include<ostream>
using namespace std;
#ifndef _FRACTIONS_
#define _FRACTIONS_

class Fractions {
public:
	//Constructor
	Fractions();
	Fractions(int, int);
	Fractions(string);
	//calculate
	Fractions reduce(void);
	Fractions multFrac(Fractions);
	Fractions divideFrac(Fractions);
	void mixedFrac(Fractions);
	Fractions addFrac(Fractions);
	Fractions subtractFrac(Fractions);
	bool equalFrac(Fractions);
	bool isLessThanFrac(Fractions);
	bool isGreaterThanFrac(Fractions);
	//accessors
	string showFrac();
	void setFrac(string);
	void setNum(int);
	void setDenom(int);
	int showDenom();
	int showNum();
	Fractions copyFrac(Fractions);
	void clearFrac();

private:
	int fractDenom;		//denominator
	int fractNum;		//numerator
	int wholePart;		//mixed number part
};

Fractions operator*(Fractions, Fractions);
Fractions operator/(Fractions, Fractions);
Fractions operator+(Fractions, Fractions);
Fractions operator-(Fractions, Fractions);
bool operator<(Fractions, Fractions);
bool operator<=(Fractions, Fractions);
bool operator>(Fractions, Fractions);
bool operator>=(Fractions, Fractions);
ostream& operator<<(ostream&, Fractions&);
#endif 

//resource file

#include "Fractions.h"
#include<conio.h>
#include<iostream>
using namespace std;
//constructors
Fractions::Fractions() 
{
	fractNum = 0;
	fractDenom = 1;
}
Fractions::Fractions(int num, int denum)
{
	fractNum = num;
	fractDenom = denum;
}
Fractions::Fractions(string frat)				//constructs class with predetermined value; format is below
{
	//format is <mixed&>num/denom
	string flag = "";
	int divplace = 0, andplace = 0;
	for (int count = 0; count < frat.length(); count++)
	{
		if (frat[count] == '/')
		{
			flag += '/';
			divplace = count;
		}
		else if (frat[count] == '&')
		{
			flag += '&';
			andplace = count;
		}
	}
	if (flag == "/")
	{
		fractNum = stoi(frat.substr(0, divplace));
		fractDenom = stoi(frat.substr(divplace + 1, frat.length() - (divplace + 1)));
	}
	else if (flag == "&/")
	{
		fractDenom = stoi(frat.substr(divplace + 1, frat.length() - (divplace + 1)));
		fractNum = stoi(frat.substr(andplace + 1, divplace - (andplace + 1)))+ fractDenom*stoi(frat.substr(0, andplace));
	}
	else
	{
		cout << "ERROR: invalid format";
	}
}
//operations
Fractions Fractions::reduce(void)				//reduces fraction, ex. 4/8 to 1/2
{
	Fractions redo;
	int biggest;
	if (fractNum < fractDenom)
		biggest = fractDenom;
	else
		biggest = fractNum;
	bool flag = true;
	while (flag == true)
		for (int reduce = 2; reduce < biggest; reduce++)
		{
			flag = false;
			if (fractNum%reduce == 0 && fractDenom%reduce == 0)
			{
				fractNum /= reduce;
				fractDenom /= reduce;
				flag = true;
			}
		}
	redo.fractNum = fractNum;
	redo.fractDenom = fractDenom;
	return redo;
	//return something!!!!!!;
}
Fractions Fractions::multFrac(Fractions multdo)	//multiplies two fractions together
{
	Fractions multing;
	multing.fractNum = fractNum * multdo.fractNum;
	multing.fractDenom = fractDenom * multdo.fractDenom;
	return multing;
}
Fractions Fractions::divideFrac(Fractions divdo)//divides one fraction by another
{
	Fractions diving;
	diving.fractNum = fractNum * divdo.fractDenom;
	diving.fractDenom = fractDenom * divdo.fractNum;
	return diving;
}
int Fractions::wholeFind(Fractions mixmake)			//returns whole number which would be associated with fraction value (IE 2 for 7/3)
{
	return mixmake.fractNum / mixmake.fractDenom;
}
Fractions Fractions::addFrac(Fractions adddo)	//adds two fractions together
{
	Fractions added;
	int num = fractDenom;
	fractNum *= adddo.fractDenom;
	fractDenom *= adddo.fractDenom;
	adddo.fractNum *= num;
	adddo.fractDenom *= num;
	added.fractNum = fractNum + adddo.fractNum;
	added.fractDenom = fractDenom;
	return added;
}
Fractions Fractions::subtractFrac(Fractions subdo)//subtracts one fraction from another
{
	Fractions subded;
	int num = fractDenom;
	fractNum *= subdo.fractDenom;
	fractDenom *= subdo.fractDenom;
	subdo.fractNum *= num;
	subdo.fractDenom *= num;
	subded.fractNum = fractNum-subdo.fractNum;
	subded.fractDenom = fractDenom;
	return subded;
}
//comparisons
bool Fractions::equalFrac(Fractions comparedo)		//determines if two fractions are equal
{
	float num1=fractNum, num2=comparedo.fractNum, denom1=fractDenom, denom2=comparedo.fractDenom;
	return (num1 / denom1 == num2 / denom2);
}
bool Fractions::isLessThanFrac(Fractions comparedo)	//determines if a fraction is less than another
{
	float num1 = fractNum, num2 = comparedo.fractNum, denom1 = fractDenom, denom2 = comparedo.fractDenom;
	return (num1 / denom1 < num2 / denom2);
}
bool Fractions::isGreaterThanFrac(Fractions comparedo)//determines if a fraction is greater than another
{
	float num1 = fractNum, num2 = comparedo.fractNum, denom1 = fractDenom, denom2 = comparedo.fractDenom;
	return (num1 / denom1 > num2 / denom2);
}
//accessors
string Fractions::showFrac()						//returns the current content of the object
{
	return (fractNum + "/" + fractDenom);
}
void Fractions::setFrac(string frat)						//changes values of numerator and denominator simultaniously
{
	//same code as constructor, so if constructor is buggy this will be too
	//format is <mixed&>num/denom
	string flag = "";
	int divplace = 0, andplace = 0;
	for (int count = 0; count < frat.length(); count++)
	{
		if (frat[count] == '/')
		{
			flag += '/';
			divplace = count;
		}
		else if (frat[count] == '&')
		{
			flag += '&';
			andplace = count;
		}
	}
	if (flag == "/")
	{
		fractNum = stoi(frat.substr(0, divplace));
		fractDenom = stoi(frat.substr(divplace + 1, frat.length() - (divplace + 1)));
	}
	else if (flag == "&/")
	{
		fractDenom = stoi(frat.substr(divplace + 1, frat.length() - (divplace + 1)));
		fractNum = stoi(frat.substr(andplace + 1, divplace - (andplace + 1))) + fractDenom * stoi(frat.substr(0, andplace));
	}
	else
	{
		cout << "ERROR: invalid format";
	}
}
void Fractions::setNum(int num)							//sets numerator to a value
{
	fractNum = num;
}
void Fractions::setDenom(int den)						//sets denominator to a value
{
	fractDenom = den;
}
int Fractions::showDenom()							//returns current value of denominator
{
	return fractDenom;
}
int Fractions::showNum()							//returns current value of numerator
{
	return fractNum;
}
Fractions Fractions::copyFrac(Fractions setdo)			//sets fraction's value to passed fraction
{
	fractNum = setdo.fractNum;
	fractDenom = setdo.fractDenom;
	return setdo;
}
void Fractions::clearFrac()							//sets fraction to 0/1
{
	fractNum = 0;
	fractDenom = 1;
}
//operators
Fractions operator*(Fractions first, Fractions second)			//multiplies two fractions
{
	return first.multFrac(second);
}
Fractions operator/(Fractions first, Fractions second)			//divides two fractions
{
	return first.divideFrac(second);
}
Fractions operator+(Fractions first, Fractions second)			//adds two fractions
{
	return first.addFrac(second);
}
Fractions operator-(Fractions first, Fractions second)			//subtracts two fractions
{
	return first.subtractFrac(second);
}

bool operator<(Fractions first, Fractions second)				//determines if a fraction is less than another 
{
	return first.isLessThanFrac(second);
}
bool operator<=(Fractions first, Fractions second)				//determines if a fraction is less than or equal to another
{
	return (first.isLessThanFrac(second) || first.equalFrac(second));
}
bool operator>(Fractions first, Fractions second)				//determines if a fraction is greater than another
{
	return first.isGreaterThanFrac(second);
}
bool operator>=(Fractions first, Fractions second)				//determines if a fraction is greater than or equal to another
{
	return (first.isGreaterThanFrac(second) || first.equalFrac(second));
}
ostream& operator<<(ostream& os, Fractions& frac)			//allows usage of cout with Fractions
{
	if (frac.showNum()/frac.showDenom > 1)
	{
		os << frac.wholeFind(frac) << "&" << frac.showNum() << "/" << frac.showDenom();
	}
	else
	{
		os << frac.showNum() << "/" << frac.showDenom();
	}
	return os;
}
